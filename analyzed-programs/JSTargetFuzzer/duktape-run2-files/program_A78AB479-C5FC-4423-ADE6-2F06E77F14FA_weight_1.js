new Int16Array(64);
new Float32Array(3);
new Int16Array(2);
const v25 = new Error();
const v28 = new Uint8Array(64, Uint8Array);
new Int8Array(13, v28, 151522616, -2147483649);
for (let v40 = 0; v40 < 42; v40++) {
    const t7 = "string";
    t7[-2] >>>= 1325607736;
    try { v28.reduce(Error, v40); } catch (e) {}
    16 << -65536;
}
new Int32Array(1022);
new Float64Array(4);
for (const v50 in "string") {
    const v53 = ("bigint")["p"];
    function f54() {
        const o55 = {
        };
        return o55;
    }
    const t21 = f54();
    t21["p" % v53] = v53;
}
[];
new Float32Array(1000);
const v64 = new Int32Array(16);
const v67 = new Int16Array(3144);
const v71 = 3144 >> v67;
let v72;
try { v72 = Int16Array(v71, 1000, 3144); } catch (e) {}
v64.byteOffset;
switch (0.01413596778607562) {
    case -1.6775380604269171e+308:
        break;
    case v64:
        try { Int32Array(); } catch (e) {}
        break;
    case -1.7976931348623157e+308:
        try { v72(); } catch (e) {}
        break;
    default:
        v67.byteOffset;
        break;
}
new Int32Array(16);
new RegExp(1000);
function F82() {
    if (!new.target) { throw 'must be called with new'; }
    this.f = true;
    this.e = true;
    this.h = true;
}
new Error();
new F82();
new F82();
const v87 = [-6705,-3,1863065743,-8,-1264365765,4294967296,-2,1808493317];
[2,536870912,-4,-1,8,7,5,1073741823,-7,42904];
[2450,65537,565674827,-2037759632,-4294967297,256,-128];
[0.005124827983396307,1.0,-5.0,-453549.7842268592,0.7136440482346572,-Infinity];
[-2.7959290226481155,-656.0896408979011,9.23960606528911,0.8286510881988536];
const v92 = [3.0,1000000.0,0.02045556907611057];
if (v92 < v25) {
    [-5.0,32.717065458179604,-0.3574585826550454,-3.0];
    [-1000000.0,-1.7976931348623157e+308,1.7976931348623157e+308];
    [969.8052578128186,-4.0,-1.0,-362.37509327342536,-1e-15,-5.279069857736262,1e-15,0.614675978271746];
} else {
    v92[Symbol.search] = v87;
}

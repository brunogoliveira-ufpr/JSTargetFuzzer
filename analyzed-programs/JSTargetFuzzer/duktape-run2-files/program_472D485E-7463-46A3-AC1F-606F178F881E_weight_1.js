new Float32Array(226);
const v14 = new Float32Array(1);
new Uint32Array(171);
const v26 = new Int8Array(13);
const v29 = new Int16Array();
const v32 = -1.0 && v29;
v32 * -9223372036854775807;
new Int32Array(1022);
const o37 = {
    "b": Uint8Array,
    4: Int16Array,
    __proto__: v26,
    [1558420117]: -4294967297,
    /*
    __proto__: v14,
    */
    "b": Uint8Array,
};
new Float64Array(4);
for (const v42 in "string") {
    const v45 = ("bigint")["p"];
    function f46() {
        const o47 = {
        };
        return o47;
    }
    const t26 = f46();
    t26["p" + v45] = v45;
    [0.3061296550938776,-5.0,2.194566802012715e+306,-874023.0493816182,1000.0,0.0];
    const v52 = [];
    function F53(a55, a56) {
        if (!new.target) { throw 'must be called with new'; }
    }
    const v57 = new F53();
    const v58 = new F53();
    v52.length;
    v57[268435440] = v58;
    new Int8Array(9, 9, 9);
    function F63(a65, a66, a67, a68) {
        if (!new.target) { throw 'must be called with new'; }
    }
}
new Float32Array(1000);
const v73 = new Int32Array(16);
const v77 = new Uint8ClampedArray(Uint8ClampedArray);
v77 % (-529538.1051807097 || 4294967296);
("T").lastIndexOf("T", -668247420);
([-4.0,NaN])[7] >>> 3171;
const v88 = new Int16Array(3144);
13 < "isConcatSpreadable";
const v94 = new Uint16Array(2);
v32[v94];
const v98 = 3144 >> v88;
let v99;
try { v99 = Int16Array(v98, 1000, 3144); } catch (e) {}
v73.byteOffset;
switch (0.01413596778607562) {
    case -1.6775380604269171e+308:
        break;
    case v73:
        try { Int32Array(); } catch (e) {}
        break;
    case -1.7976931348623157e+308:
        try { v99(); } catch (e) {}
        break;
    default:
        v88.byteOffset;
        break;
}

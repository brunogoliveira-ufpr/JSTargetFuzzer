const v8 = new Int16Array(1000);
v8.f = true;
function F12(a14, a15) {
    if (!new.target) { throw 'must be called with new'; }
}
const v16 = new F12(F12, F12);
v16 + 5.863003234916803;
v8.toString = Int16Array;
[-780686.7794592782,-4.0];
[4.639690461442756,2.2250738585072014e-308];
[835856.4813521239,-0.0,630675.7813915971,1.7798626409390295,-2.0,-3.0,-1e-15,5.899280455478084e+307,0.18994267618908722,-0.0];
new Int16Array(1715);
new Uint32Array(2);
new Int8Array(13);
new Int32Array(1022);
new Float64Array(4);
for (const v43 in "string") {
    const v46 = ("bigint")["p"];
    function f47() {
        const o48 = {
        };
        return o48;
    }
    const t23 = f47();
    t23["p" + v46] = v46;
}
new Float32Array(1000);
const v56 = new Int32Array(16);
const v59 = new Int16Array(3144);
const v63 = 3144 >> v59;
let v64;
try { v64 = Int16Array(v63, 1000, 3144); } catch (e) {}
v56.byteOffset;
switch (0.01413596778607562) {
    case -1.6775380604269171e+308:
        break;
    case v56:
        const o68 = {
            "maxByteLength": 1073741825,
        };
        const v70 = new SharedArrayBuffer(257, o68);
        new Float64Array(v70);
        try { Int32Array(); } catch (e) {}
        break;
    case -1.7976931348623157e+308:
        try { v64(); } catch (e) {}
        break;
    default:
        v59.byteOffset;
        break;
}

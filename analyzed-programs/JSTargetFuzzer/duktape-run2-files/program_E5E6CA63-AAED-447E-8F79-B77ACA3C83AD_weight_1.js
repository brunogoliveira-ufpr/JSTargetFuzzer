const v5 = new Uint8Array(16);
new Int8Array(4);
const v11 = new Int32Array(0);
new Int8Array(13);
const v23 = new Int32Array(1022);
const v26 = new Float64Array(4);
for (const v28 in "string") {
    const v31 = ("bigint")["p"];
    function f32() {
        const o33 = {
        };
        return o33;
    }
    const t13 = f32();
    t13["p" + v31] = v31;
}
for (let v39 = 0; v39 < 34; v39++) {
    8 in v26;
}
const v41 = [2.0,-116.77494940045176];
function F44(a46, a47, a48, a49) {
    if (!new.target) { throw 'must be called with new'; }
    this.f = v41;
}
new F44(-1329257878, v41, 48247, v41);
v23.buffer;
for (let v52 = 0; v52 < 32; v52++) {
    v11["p" + v52] = v52;
}
let v56;
try { v56 = v5("string", 1022, v11, 0.0); } catch (e) {}
try { v56(8, v56, -3); } catch (e) {}
new Float32Array(1000);
const v62 = new Int32Array(16);
const v65 = new Int16Array(3144);
const v69 = 3144 >> v65;
let v70;
try { v70 = Int16Array(v69, 1000, 3144); } catch (e) {}
v62.byteOffset;
switch (0.01413596778607562) {
    case -1.6775380604269171e+308:
        break;
    case v62:
        try { Int32Array(); } catch (e) {}
        break;
    case -1.7976931348623157e+308:
        try { v70(); } catch (e) {}
        break;
    default:
        v65.byteOffset;
        break;
}

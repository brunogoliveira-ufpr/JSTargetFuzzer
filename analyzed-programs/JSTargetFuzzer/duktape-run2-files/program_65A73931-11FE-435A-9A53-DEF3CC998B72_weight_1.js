[];
function f1() {
    return f1;
}
const v4 = new Int32Array();
for (let v5 = 0; v5 < 5; v5++) {
    v4["p" + v5] = v5;
}
"p" / -9007199254740991;
function F15(a17) {
    if (!new.target) { throw 'must be called with new'; }
}
F15 > ("IMJBi").lastIndexOf();
function F28(a30) {
    if (!new.target) { throw 'must be called with new'; }
    const o31 = {
        __proto__: this,
        "b": Uint8Array,
    };
    try { a30(); } catch (e) {}
}
new F28();
new Float32Array(1000);
const v39 = new Int32Array(16);
const v42 = new Int16Array(3144);
const v46 = 3144 >> v42;
let v47;
try { v47 = Int16Array(v46, 1000, 3144); } catch (e) {}
const v50 = ("bigint")["p"];
const o51 = {
};
o51["p" % v50] = v50;
v39.byteOffset;
switch (0.01413596778607562) {
    case -1.7976931348623157e+308:
        try {
        const t0 = 536870888;
        t0();
        } catch (e) {}
        break;
    case v47:
    default:
        v42.byteOffset;
        !14;
        for (let v59 = 0; v59 < 5; v59++) {
            "p" / v59;
        }
        break;
}

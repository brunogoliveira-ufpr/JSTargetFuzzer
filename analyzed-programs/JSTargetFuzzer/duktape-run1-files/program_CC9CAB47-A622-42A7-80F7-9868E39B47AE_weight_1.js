const v0 = [8.619513133404375,1000000000000.0,0.9387634146355246,-8.300349255608907,686.6275861512231,2.547031565251947];
[0.9194118272744621,Infinity,-1000000000.0,1000.0,-1.0,-320.9694941512979,0.5360400905923456,1.0,-1.0];
const v2 = [0.08996329264859926,0.9197724229084364,-390.6754657730571,2.2250738585072014e-308];
function F9(a11, a12, a13) {
    if (!new.target) { throw 'must be called with new'; }
}
const v14 = new F9();
let v15 = 541964588;
const v16 = v15++;
v15 | v14;
try { v14["p"](268435439, "p"); } catch (e) {}
function F22(a24, a25) {
    if (!new.target) { throw 'must be called with new'; }
    this.c = v16;
}
new F22(v16, v0);
new F22(3, v2);
const v28 = new F22(38406, v14);
new Float64Array(1000);
const v35 = new Float64Array(16, 268435439, 1000);
v35 in v0;
v35.byteOffset;
new Float64Array(3161);
new Uint32Array(1448);
const v48 = [-2147483647,4294967295,2147483648,255,5,-268435456,-5,-65535,30881,1073741824];
const v49 = [-1,5,0];
const v50 = [268435439,-9223372036854775808,-41245,536870889,35223];
function F51(a53, a54) {
    if (!new.target) { throw 'must be called with new'; }
    this[Uint32Array] = v28;
    this.c = a53;
    v28[Symbol.unscopables] = 1000;
    this.g = a54;
}
new F51(v50, v49);
new F51(v49, v50);
new F51(v50, v48);
let v64 = 0;
while (v64 < 0) {
    v48 ** -1413170494;
    const v68 = [15,-195573067,9007199254740992,4294967295,4294967295,27804,-5,4566,-63342,-17886];
    [-65536,536870888,-4294967295,9,9007199254740992,-39672,7,65535,5];
    [1768458921,-1865700706,-1459930215,4461];
    v64++;
    const v76 = ~v68;
    const v77 = v68 % v68;
    2.0 & v76;
    v68 >>> v77;
    Math.log1p(1572362939);
}

new Float64Array(3691);
~541964588;
const o12 = {
};
do {
} while (0)
new Uint16Array(8);
new Uint32Array(64);
function F19() {
    if (!new.target) { throw 'must be called with new'; }
}
const v21 = new F19();
v21[-536870912] |= 0;
const v30 = ["fw6P",-4294967296,-4294967296,"fw6P","fw6P"];
const v31 = ["boolean",-4294967296,4096];
const v32 = ["fw6P","boolean",v31,256,"boolean"];
Object.defineProperty([-1.0,2.0,1.0,1000.0,0.11549172773170746,887.1856544747855,-5.0,5.0,2.2250738585072014e-308], 2150, { value: Array().length });
let v37 = 0;
v37++;
~Uint8Array;
new Uint16Array(Uint16Array, Uint16Array, Uint16Array);
function F43(a45, a46, a47) {
    if (!new.target) { throw 'must be called with new'; }
    this.e = -4294967296;
    this.a = v30;
}
const v48 = new F43("-12992", v30, v32);
function F49() {
    if (!new.target) { throw 'must be called with new'; }
    Object.defineProperty(this, this, { writable: true, get: Array, set: Array });
    Math.exp(-65535 >>> Array);
    this % Array;
    -65535 & -65535;
}
let v58 = 0;
v58++;
function F60(a62, a63, a64, a65) {
    if (!new.target) { throw 'must be called with new'; }
}
new F60();
new F43("-12992", v31, v32);
const v68 = new F43("-12992", v30, v32);
const v71 = v68[Symbol.split];
new Array(16);
Symbol(v58);
Array(256);
[536870912,220536391,-64821,10000];
[-4716,59655,5,9007199254740990];
[3];
try { v31.sort(v71); } catch (e) {}
let v83 = 541964588;
v83++;
Array().length;
function F88(a90) {
    if (!new.target) { throw 'must be called with new'; }
}
new F88(F88);
const v92 = v83 | v48;
const v93 = ~v83;
const v94 = v93 || v83;
Float64Array << Uint8Array;
function F98() {
    if (!new.target) { throw 'must be called with new'; }
    if (this == this) {
        d.f += -2;
    } else {
        new Float32Array(2);
        new Uint16Array(8);
        new Uint8ClampedArray(1000);
    }
}
v93 ** v48;
v94 / v92;

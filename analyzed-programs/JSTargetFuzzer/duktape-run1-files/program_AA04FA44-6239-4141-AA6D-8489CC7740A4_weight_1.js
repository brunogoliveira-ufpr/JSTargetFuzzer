[-6,6,39413,256,-62025];
[4096,-128,13809,-4294967297,65536,-9007199254740992,41035,536870888,-13];
[21762,-55183];
new Int8Array(5);
new Uint16Array(1814);
new Int16Array(8);
new Int32Array(1000);
new Float64Array(14);
new Float32Array(1000);
new Uint16Array(1000);
new Float32Array(14);
new Uint32Array(1024, -1, Uint32Array, 5);
Math.round(Infinity);
+(Infinity / 65524);
"getOwnPropertyNames" != "object";
[[-2]];
const v64 = new Array(252);
try { ("0LH").trimLeft(); } catch (e) {}
6 <= Float32Array;
const v79 = new Uint16Array(3036);
if ([1.5422187059955767e+308,634.4415697594864]) {
    const v83 = 1e-15 >> 1;
    [2.0,-0.55292837950023,-0.0,Infinity,660089.5868542092];
    (170836399 || 541964588) / -1368938825;
    v79.byteOffset = v83;
} else {
    const v92 = Array(252);
    v92[v92];
    function F94(a96, a97, a98) {
        if (!new.target) { throw 'must be called with new'; }
    }
    const v99 = new F94();
    let v100 = 541964588;
    v100++;
    let v102 = v100 | v99;
    v102 %= 4073;
    new Float32Array(3036);
    new Uint8Array(2);
    new Float64Array(3);
}
0 >= 1;
[61612,61612,61612];
try {
const t0 = 474369557;
t0();
} catch (e) {}
const o119 = {
};
const v121 = new Proxy(Array, o119);
v121["imul"];
const v123 = [-35406,-128,268435439];
const v124 = [-7648,-56818,16,4,1007569727,4];
const v125 = [-2];
let v126 = [v123];
const v127 = [v125,v126,v125];
for (let i = 0; i < 5; i++) {
    2.50552314384502e+306 in v127;
    v124[2974113795] ||= v126 &= v127;
}
("imul")[512];
const o133 = {
};
const v135 = new Proxy(Array, o133);
try { ("imul").charCodeAt(1024, Uint32Array, v125); } catch (e) {}
new Array(252);
new Date();
v135[v64];

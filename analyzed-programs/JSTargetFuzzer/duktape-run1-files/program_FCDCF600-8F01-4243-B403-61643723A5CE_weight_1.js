[7,7];
function F7(a9, a10) {
    if (!new.target) { throw 'must be called with new'; }
    this.c = 7;
}
const v11 = new F7(F7, F7);
v11.c;
let v15 = 0;
while (v15 < 1) {
    v15++;
}
Array(1346);
new Float64Array(65535);
new Int16Array(128);
128 !== 128;
+1975383941;
function F31() {
    if (!new.target) { throw 'must be called with new'; }
}
let v34 = 4073;
const v37 = new Uint16Array(3036);
if ([1.5422187059955767e+308,634.4415697594864]) {
    v37.byteOffset = 1e-15 >> 4.0;
} else {
    v34 %= v34;
    new Float32Array(691);
    new Uint8Array(2);
    new Float64Array(3);
}
new Uint32Array(3);
const o54 = {
};
o54[10] /= 10;
function f55() {
}
function F59(a61, a62) {
    if (!new.target) { throw 'must be called with new'; }
    this.g = 16132;
}
const v63 = new F59(0, 15);
[-2] | [-4294967297,-1282486056,2147483647,-268435456,-141,-56677,1247693995];
function F68(a70, a71, a72) {
    if (!new.target) { throw 'must be called with new'; }
}
const v73 = new F68(F68, F68, F68);
~2213 ** v73;
const v76 = new F59(-1368938825, 15);
new F59(0, -1368938825);
if (536870888 >= F59) {
    v76.__proto__ = v63;
    try {
    const t0 = 0;
    t0();
    } catch (e) {}
    for (let v83 = 0; v83 < 32; v83++) {
        Symbol.split;
        const v86 = [9.327053549563642e+307,83.33019193195969,672.4203684783768];
        try { v86.reduceRight(v86, v86); } catch (e) {}
        byteOffset.valueOf(byteOffset);
        v63["p" + v83] = v83;
    }
} else {
    v63[-1368938825] = 536870888;
    v76[2133] >>= 170836399;
}

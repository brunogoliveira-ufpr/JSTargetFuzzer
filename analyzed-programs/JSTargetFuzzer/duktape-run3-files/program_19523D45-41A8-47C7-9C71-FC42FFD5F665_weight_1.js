let v8 = -11;
const v9 = [1169756282,255,-4294967296,-55779,3144,4,-65536];
try {
const t0 = "MAX_VALUE";
t0("MAX_VALUE", v8, v9);
} catch (e) {}
++v8;
const v20 = new Float32Array();
function f23(a24, a25) {
    const o26 = {
        [a25]: v20,
    };
    return 512;
}
f23(-3, 512);
const v28 = new Int32Array(2);
const v31 = new Uint16Array(8);
const v34 = new Int8Array(49);
[Int32Array,v28,Uint16Array,Uint16Array];
[0.1632289144552994,-1.6267173916314004e+308,-3.6429288914551514e+307,-1e-15,0.0,1000000000000.0,1.8804368243419304e+307];
CBOR.decode * CBOR.decode;
const v42 = ([-20945,-1024,11,5,4294967297,65536]).indexOf;
[-9007199254740990] < v42;
const v46 = new Uint32Array(Uint32Array, Uint32Array, Uint32Array);
v46.buffer;
Reflect.apply(v42, 0.0);
[Uint16Array,Int32Array,v34,v34,v31];
[8];
function F54() {
    if (!new.target) { throw 'must be called with new'; }
    new Uint16Array();
    -13346 >> -13346;
    Math.min(0.36441061929000385 ^ [-11,-6]);
    this.c = 1073741825;
    this.h = 1073741825;
    new Uint16Array();
    this & -7456;
    const o74 = {
        toString(a72, a73) {
            return -1024;
        },
    };
    this.f = 1073741825;
    try { this.o(this, this, Int8Array); } catch (e) {}
    const o79 = {
        valueOf() {
            return this;
        },
        set b(a78) {
        },
    };
    new Proxy(this, o79);
}
const v82 = new F54();
const v83 = new F54();
new F54();
new Int16Array(255);
new Int16Array(1000);
function f92() {
    return arguments;
}
f92(Int16Array, f92, 512);
new Uint8ClampedArray(1000);
v82[v82];
let v101 = 10;
for (; v101--;) {
    let v107;
    try { v107 = Int8Array(); } catch (e) {}
    const v109 = new ArrayBuffer(v107);
    new Uint8ClampedArray(v109);
    v83.f = Int16Array;
}

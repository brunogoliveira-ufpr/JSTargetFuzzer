function F0() {
    if (!new.target) { throw 'must be called with new'; }
    this.c = -2;
}
const v3 = new F0();
const v4 = new F0();
new F0();
const v6 = [2.0,7.453863807812294e+307];
const v7 = [-7.5977984890891e+307,1.715945494274749e+308,-971083.7379835859,161297.1833486806,1e-15];
const v8 = [-1000000.0,-1.9708077420319032];
const v9 = [F0];
[v8,F0,v9];
[v6,v7,v4];
function F16(a18, a19) {
    if (!new.target) { throw 'must be called with new'; }
}
const v20 = new F16(-1292587615, -1292587615);
let v21 = new F16();
new Uint16Array(16);
let o28 = {
};
const v29 = o28--;
const v31 = new Float32Array();
for (let v34 = 0; v34 < 87; v34++) {
    o28 |= v34;
    v21 = v3;
}
const v35 = v6 instanceof Uint16Array;
v29 / 16;
function f37() {
    return f37;
}
-9007199254740990 * f37;
new Uint32Array(462);
function F43(a45, a46) {
    if (!new.target) { throw 'must be called with new'; }
    this.e = a46;
    this.d = -1073741824;
    const v47 = this !== v8;
    v47 ? this : v8;
    2 instanceof F16;
    v7[v47];
    v31["map"](a45, v9);
    function F53() {
        if (!new.target) { throw 'must be called with new'; }
    }
    new F53();
    const v57 = ["symbol"];
    v57 & v57;
}
let v61;
try { v61 = o28.freeze(-9223372036854775807, F43, -9223372036854775807, 91817631); } catch (e) {}
v61 < v31;
new Float32Array(6);
v3[v35];
function f75() {
}
Uint32Array.h = URIError;
Uint32Array ** undefined;
Uint32Array ** undefined;
-1292587615 % F16;
v20.__proto__ = v21;
